{"version":3,"file":"highlightWords.js","sourceRoot":"","sources":["../src/highlightWords.ts"],"names":[],"mappings":"AAOA,MAAM,UAAU,QAAQ,CAAC,QAAqB,EAAE,IAAY;IAExD,IAAI,IAAI,IAAI,EAAE;QAAE,OAAO;IACvB,MAAM,MAAM,GAAG,QAAQ,CAAC,gBAAgB,CAAC,QAAQ,EAAE,UAAU,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;IAC/E,IAAI,IAAI,CAAC;IACT,IAAI,GAAG,MAAM,CAAC,QAAQ,EAAE,CAAC;IACzB,OAAO,IAAI,EAAE,CAAC;QAQV,IAAI,QAAQ,GAAG,MAAM,CAAC,QAAQ,EAAE,CAAA;QAChC,MAAM,UAAU,GAAG,IAAI,CAAC,UAAW,CAAC;QACpC,MAAM,KAAK,GAAG,IAAI,MAAM,CAAC,IAAI,IAAI,GAAG,EAAE,IAAI,CAAC,CAAC;QAC5C,IAAI,IAAI,CAAC,SAAS,IAAI,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC;YAE/C,MAAM,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,KAAK,EAAE,iBAAiB,CAAC,CAAC;YAEjE,MAAM,OAAO,GAAG,QAAQ,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;YAC9C,OAAO,CAAC,SAAS,GAAG,OAAO,CAAC;YAG5B,OAAO,OAAO,CAAC,UAAU,EAAE,CAAC;gBACxB,UAAU,CAAC,YAAY,CAAC,OAAO,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;YACtD,CAAC;YACD,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QACjC,CAAC;QACD,IAAI,GAAG,QAAQ,CAAC;IACpB,CAAC;AACL,CAAC;AASD,MAAM,UAAU,UAAU,CAAC,QAAqB;IAE5C,QAAQ,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QAC/C,MAAM,MAAM,GAAG,IAAI,CAAC,UAAW,CAAC;QAChC,OAAO,IAAI,CAAC,UAAU,EAAE,CAAC;YACrB,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;QAE/C,CAAC;QACD,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QAEzB,MAAM,CAAC,SAAS,EAAE,CAAC;IAEvB,CAAC,CAAC,CAAC;AACP,CAAC","sourcesContent":["/**\n * Highlight given word in child text nodes of given root node. \n * Highlighting is implemented by wrapping the word between <mark>..</mark> tags.\n * The mark tag is supported in HTML5.\n * @param rootNode the parse tree\n * @return the visitor result\n */\nexport function markText(rootNode: HTMLElement, word: string) {\n    // word can also be empty string \"\" which we do not mark!\n    if (word == \"\") return;\n    const walker = document.createTreeWalker(rootNode, NodeFilter.SHOW_TEXT, null);\n    let node;\n    node = walker.nextNode();\n    while (node) {\n        // we much fetch nextNode already, because\n        // if we have a match we create a newNode based on 'node'\n        // place newNode before 'node' and remove 'node'.\n        // If walker's current node is 'node', and we remove it,\n        // then the walker state is affected such that if stops.\n        // We prevent this by already taking a nextNode before\n        // handling 'node'.\n        let nextNode = walker.nextNode()\n        const parentNode = node.parentNode!;\n        const regex = new RegExp(`(${word})`, 'gi');\n        if (node.nodeValue && regex.test(node.nodeValue)) {\n            // create new html text from text in textnode \n            const newHTML = node.nodeValue.replace(regex, '<mark>$1</mark>');\n            // place this text in a div element as innerHTML making the text being parsed as html!\n            const tempDiv = document.createElement('div');\n            tempDiv.innerHTML = newHTML;\n            // take the newly html nodes inside the div (tempDiv.firstChild) and place it in parentnode\n            //  as child before node (we are changing), then remove this old node from parent. (only remaining the newly html nodes in the parent node) \n            while (tempDiv.firstChild) {\n                parentNode.insertBefore(tempDiv.firstChild, node);\n            }\n            parentNode.removeChild(node);\n        }\n        node = nextNode;\n    }\n}\n\n/**\n * Remove all highlighting in child text nodes of given root node.\n * Remove highlighting is implemented by unwrapping words between <mark>..</mark> tags.\n * The mark tag is supported in HTML5.\n * @param ctx the parse tree\n * @return the visitor result\n */\nexport function unMarkText(rootNode: HTMLElement) {\n    // Unwrap any <mark> elements inside the item from previous search\n    rootNode.querySelectorAll(\"mark\").forEach((mark) => {\n        const parent = mark.parentNode!;\n        while (mark.firstChild) {\n            parent.insertBefore(mark.firstChild, mark);\n            // bla <mark>textinside</mark>  --> bla textinside<mark>textinside</mark>\n        }\n        parent.removeChild(mark);\n        // bla textinside<mark>textinside</mark> -> bla textinside\n        parent.normalize(); // after removing mark tags we get multiple adjacent text nodes, with normalized they get merged into one\n        // without normalizing a split text could not be matched by a next search anymore\n    });\n}"]}